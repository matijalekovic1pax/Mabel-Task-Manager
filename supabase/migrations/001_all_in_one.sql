-- ============================================================
-- Consolidated Supabase Migration (001-011)
-- Generated by concatenating ordered migration files.
-- ============================================================

-- >>> BEGIN 001_initial_schema.sql
-- ============================================================
-- Mabel Task Manager — Initial Schema
-- ============================================================

-- Custom Enums
CREATE TYPE task_category AS ENUM (
  'financial',
  'project',
  'hr_operations',
  'client_relations',
  'pr_marketing',
  'administrative'
);

CREATE TYPE task_priority AS ENUM ('urgent', 'high', 'normal', 'low');

CREATE TYPE task_status AS ENUM (
  'pending',
  'in_review',
  'approved',
  'rejected',
  'needs_more_info',
  'deferred',
  'delegated',
  'resolved'
);

CREATE TYPE user_role AS ENUM ('ceo', 'team_member');

CREATE TYPE notification_type AS ENUM (
  'task_submitted',
  'task_resolved',
  'needs_more_info',
  'info_provided',
  'task_delegated',
  'task_updated',
  'comment_added',
  'deadline_approaching',
  'task_overdue'
);

-- ============================================================
-- TABLES
-- ============================================================

-- Profiles (extends auth.users)
CREATE TABLE public.profiles (
  id          UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  email       TEXT NOT NULL,
  full_name   TEXT NOT NULL,
  role        user_role NOT NULL DEFAULT 'team_member',
  avatar_url  TEXT,
  department  TEXT,
  is_active   BOOLEAN NOT NULL DEFAULT true,
  created_at  TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at  TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX idx_profiles_role ON public.profiles(role);
CREATE INDEX idx_profiles_is_active ON public.profiles(is_active);

-- Allowed Emails (whitelist for Google Workspace users)
CREATE TABLE public.allowed_emails (
  id         UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email      TEXT NOT NULL UNIQUE,
  role       user_role NOT NULL DEFAULT 'team_member',
  added_by   UUID REFERENCES public.profiles(id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Tasks
CREATE TABLE public.tasks (
  id               UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  title            TEXT NOT NULL CHECK (char_length(title) BETWEEN 3 AND 200),
  description      TEXT NOT NULL CHECK (char_length(description) >= 10),
  category         task_category NOT NULL,
  priority         task_priority NOT NULL DEFAULT 'normal',
  status           task_status NOT NULL DEFAULT 'pending',
  submitted_by     UUID NOT NULL REFERENCES public.profiles(id),
  resolved_by      UUID REFERENCES public.profiles(id),
  assigned_to      UUID REFERENCES public.profiles(id),
  delegation_note  TEXT,
  deadline         TIMESTAMPTZ,
  submitted_at     TIMESTAMPTZ NOT NULL DEFAULT now(),
  resolved_at      TIMESTAMPTZ,
  updated_at       TIMESTAMPTZ NOT NULL DEFAULT now(),
  resolution_note  TEXT,
  is_archived      BOOLEAN NOT NULL DEFAULT false,
  reference_number TEXT UNIQUE
);

CREATE INDEX idx_tasks_status ON public.tasks(status);
CREATE INDEX idx_tasks_priority ON public.tasks(priority);
CREATE INDEX idx_tasks_category ON public.tasks(category);
CREATE INDEX idx_tasks_submitted_by ON public.tasks(submitted_by);
CREATE INDEX idx_tasks_assigned_to ON public.tasks(assigned_to) WHERE assigned_to IS NOT NULL;
CREATE INDEX idx_tasks_deadline ON public.tasks(deadline) WHERE deadline IS NOT NULL;
CREATE INDEX idx_tasks_submitted_at ON public.tasks(submitted_at DESC);
CREATE INDEX idx_tasks_status_priority ON public.tasks(status, priority);

-- Task Comments
CREATE TABLE public.task_comments (
  id         UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  task_id    UUID NOT NULL REFERENCES public.tasks(id) ON DELETE CASCADE,
  author_id  UUID NOT NULL REFERENCES public.profiles(id),
  content    TEXT NOT NULL CHECK (char_length(content) >= 1),
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX idx_comments_task_id ON public.task_comments(task_id);
CREATE INDEX idx_comments_created_at ON public.task_comments(task_id, created_at);

-- Task Attachments
CREATE TABLE public.task_attachments (
  id           UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  task_id      UUID NOT NULL REFERENCES public.tasks(id) ON DELETE CASCADE,
  uploaded_by  UUID NOT NULL REFERENCES public.profiles(id),
  file_name    TEXT NOT NULL,
  file_size    BIGINT NOT NULL,
  file_type    TEXT NOT NULL,
  storage_path TEXT NOT NULL,
  created_at   TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX idx_attachments_task_id ON public.task_attachments(task_id);

-- Notifications
CREATE TABLE public.notifications (
  id           UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  recipient_id UUID NOT NULL REFERENCES public.profiles(id),
  type         notification_type NOT NULL,
  title        TEXT NOT NULL,
  message      TEXT NOT NULL,
  task_id      UUID REFERENCES public.tasks(id) ON DELETE CASCADE,
  is_read      BOOLEAN NOT NULL DEFAULT false,
  created_at   TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX idx_notifications_recipient ON public.notifications(recipient_id, is_read, created_at DESC);
CREATE INDEX idx_notifications_unread ON public.notifications(recipient_id) WHERE is_read = false;

-- ============================================================
-- SEQUENCES & TRIGGERS
-- ============================================================

-- Auto-generate task reference numbers (MTM-0001, MTM-0002, ...)
CREATE SEQUENCE task_reference_seq START 1;

CREATE OR REPLACE FUNCTION generate_task_reference()
RETURNS TRIGGER AS $$
BEGIN
  NEW.reference_number := 'MTM-' || LPAD(nextval('task_reference_seq')::TEXT, 4, '0');
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER set_task_reference
  BEFORE INSERT ON public.tasks
  FOR EACH ROW
  EXECUTE FUNCTION generate_task_reference();

-- Auto-update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER set_tasks_updated_at
  BEFORE UPDATE ON public.tasks
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at();

CREATE TRIGGER set_profiles_updated_at
  BEFORE UPDATE ON public.profiles
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at();

-- Auto-create profile on new user signup (if email is in allowed_emails)
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
DECLARE
  allowed_role user_role;
BEGIN
  SELECT role INTO allowed_role
  FROM public.allowed_emails
  WHERE email = NEW.email;

  IF allowed_role IS NOT NULL THEN
    INSERT INTO public.profiles (id, email, full_name, role, avatar_url)
    VALUES (
      NEW.id,
      NEW.email,
      COALESCE(NEW.raw_user_meta_data->>'full_name', NEW.raw_user_meta_data->>'name', split_part(NEW.email, '@', 1)),
      allowed_role,
      NEW.raw_user_meta_data->>'avatar_url'
    );
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW
  EXECUTE FUNCTION public.handle_new_user();

-- ============================================================
-- ROW LEVEL SECURITY
-- ============================================================

-- PROFILES
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

CREATE POLICY "profiles_select_all"
  ON public.profiles FOR SELECT
  TO authenticated
  USING (true);

CREATE POLICY "profiles_update_own"
  ON public.profiles FOR UPDATE
  TO authenticated
  USING (auth.uid() = id)
  WITH CHECK (auth.uid() = id);

-- TASKS
ALTER TABLE public.tasks ENABLE ROW LEVEL SECURITY;

CREATE POLICY "tasks_select"
  ON public.tasks FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.profiles
      WHERE profiles.id = auth.uid() AND profiles.role = 'ceo'
    )
    OR submitted_by = auth.uid()
    OR assigned_to = auth.uid()
  );

CREATE POLICY "tasks_insert"
  ON public.tasks FOR INSERT
  TO authenticated
  WITH CHECK (
    submitted_by = auth.uid()
    AND EXISTS (
      SELECT 1 FROM public.profiles
      WHERE profiles.id = auth.uid() AND profiles.is_active = true
    )
  );

CREATE POLICY "tasks_update"
  ON public.tasks FOR UPDATE
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.profiles
      WHERE profiles.id = auth.uid() AND profiles.role = 'ceo'
    )
    OR (
      submitted_by = auth.uid()
      AND status IN ('pending', 'needs_more_info')
    )
    OR (
      assigned_to = auth.uid()
      AND status = 'delegated'
    )
  );

-- TASK COMMENTS
ALTER TABLE public.task_comments ENABLE ROW LEVEL SECURITY;

CREATE POLICY "comments_select"
  ON public.task_comments FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.tasks
      WHERE tasks.id = task_comments.task_id
      AND (
        tasks.submitted_by = auth.uid()
        OR tasks.assigned_to = auth.uid()
        OR EXISTS (
          SELECT 1 FROM public.profiles
          WHERE profiles.id = auth.uid() AND profiles.role = 'ceo'
        )
      )
    )
  );

CREATE POLICY "comments_insert"
  ON public.task_comments FOR INSERT
  TO authenticated
  WITH CHECK (
    author_id = auth.uid()
    AND EXISTS (
      SELECT 1 FROM public.tasks
      WHERE tasks.id = task_comments.task_id
      AND (
        tasks.submitted_by = auth.uid()
        OR tasks.assigned_to = auth.uid()
        OR EXISTS (
          SELECT 1 FROM public.profiles
          WHERE profiles.id = auth.uid() AND profiles.role = 'ceo'
        )
      )
    )
  );

-- TASK ATTACHMENTS
ALTER TABLE public.task_attachments ENABLE ROW LEVEL SECURITY;

CREATE POLICY "attachments_select"
  ON public.task_attachments FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.tasks
      WHERE tasks.id = task_attachments.task_id
      AND (
        tasks.submitted_by = auth.uid()
        OR tasks.assigned_to = auth.uid()
        OR EXISTS (
          SELECT 1 FROM public.profiles
          WHERE profiles.id = auth.uid() AND profiles.role = 'ceo'
        )
      )
    )
  );

CREATE POLICY "attachments_insert"
  ON public.task_attachments FOR INSERT
  TO authenticated
  WITH CHECK (
    uploaded_by = auth.uid()
    AND EXISTS (
      SELECT 1 FROM public.tasks
      WHERE tasks.id = task_attachments.task_id
      AND (
        tasks.submitted_by = auth.uid()
        OR tasks.assigned_to = auth.uid()
      )
    )
  );

-- NOTIFICATIONS
ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;

CREATE POLICY "notifications_select_own"
  ON public.notifications FOR SELECT
  TO authenticated
  USING (recipient_id = auth.uid());

CREATE POLICY "notifications_update_own"
  ON public.notifications FOR UPDATE
  TO authenticated
  USING (recipient_id = auth.uid())
  WITH CHECK (recipient_id = auth.uid());

-- ALLOWED EMAILS
ALTER TABLE public.allowed_emails ENABLE ROW LEVEL SECURITY;

CREATE POLICY "allowed_emails_ceo_select"
  ON public.allowed_emails FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.profiles
      WHERE profiles.id = auth.uid() AND profiles.role = 'ceo'
    )
  );

CREATE POLICY "allowed_emails_ceo_insert"
  ON public.allowed_emails FOR INSERT
  TO authenticated
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM public.profiles
      WHERE profiles.id = auth.uid() AND profiles.role = 'ceo'
    )
  );

CREATE POLICY "allowed_emails_ceo_delete"
  ON public.allowed_emails FOR DELETE
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.profiles
      WHERE profiles.id = auth.uid() AND profiles.role = 'ceo'
    )
  );

-- ============================================================
-- STORAGE
-- ============================================================

INSERT INTO storage.buckets (id, name, public)
VALUES ('task-attachments', 'task-attachments', false);

CREATE POLICY "task_attachments_upload"
  ON storage.objects FOR INSERT
  TO authenticated
  WITH CHECK (bucket_id = 'task-attachments');

CREATE POLICY "task_attachments_read"
  ON storage.objects FOR SELECT
  TO authenticated
  USING (bucket_id = 'task-attachments');

CREATE POLICY "task_attachments_delete"
  ON storage.objects FOR DELETE
  TO authenticated
  USING (bucket_id = 'task-attachments');

-- ============================================================
-- REALTIME
-- ============================================================

ALTER PUBLICATION supabase_realtime ADD TABLE public.tasks;
ALTER PUBLICATION supabase_realtime ADD TABLE public.notifications;
ALTER PUBLICATION supabase_realtime ADD TABLE public.task_comments;

-- <<< END 001_initial_schema.sql

-- >>> BEGIN 002_super_admin_enum.sql
-- ============================================================
-- Add super_admin to user_role enum
-- This MUST be committed in its own transaction before
-- any policies can reference the new value.
-- ============================================================

ALTER TYPE user_role ADD VALUE 'super_admin';

-- <<< END 002_super_admin_enum.sql

-- >>> BEGIN 003_super_admin_policies.sql
-- ============================================================
-- Update RLS policies to grant super_admin full access
-- Run AFTER 002_super_admin_enum.sql has been committed.
-- ============================================================

-- PROFILES: super_admin can update any profile
DROP POLICY IF EXISTS "profiles_update_own" ON public.profiles;

CREATE POLICY "profiles_update"
  ON public.profiles FOR UPDATE
  TO authenticated
  USING (
    auth.uid() = id
    OR EXISTS (
      SELECT 1 FROM public.profiles
      WHERE profiles.id = auth.uid() AND profiles.role = 'super_admin'
    )
  );

-- TASKS: super_admin has full access (select, insert, update, delete)
DROP POLICY IF EXISTS "tasks_select" ON public.tasks;
DROP POLICY IF EXISTS "tasks_update" ON public.tasks;

CREATE POLICY "tasks_select"
  ON public.tasks FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.profiles
      WHERE profiles.id = auth.uid() AND profiles.role IN ('ceo', 'super_admin')
    )
    OR submitted_by = auth.uid()
    OR assigned_to = auth.uid()
  );

CREATE POLICY "tasks_update"
  ON public.tasks FOR UPDATE
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.profiles
      WHERE profiles.id = auth.uid() AND profiles.role IN ('ceo', 'super_admin')
    )
    OR (
      submitted_by = auth.uid()
      AND status IN ('pending', 'needs_more_info')
    )
    OR (
      assigned_to = auth.uid()
      AND status = 'delegated'
    )
  );

CREATE POLICY "tasks_delete"
  ON public.tasks FOR DELETE
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.profiles
      WHERE profiles.id = auth.uid() AND profiles.role = 'super_admin'
    )
  );

-- TASK COMMENTS: super_admin can see and add comments on any task
DROP POLICY IF EXISTS "comments_select" ON public.task_comments;
DROP POLICY IF EXISTS "comments_insert" ON public.task_comments;

CREATE POLICY "comments_select"
  ON public.task_comments FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.tasks
      WHERE tasks.id = task_comments.task_id
      AND (
        tasks.submitted_by = auth.uid()
        OR tasks.assigned_to = auth.uid()
        OR EXISTS (
          SELECT 1 FROM public.profiles
          WHERE profiles.id = auth.uid() AND profiles.role IN ('ceo', 'super_admin')
        )
      )
    )
  );

CREATE POLICY "comments_insert"
  ON public.task_comments FOR INSERT
  TO authenticated
  WITH CHECK (
    author_id = auth.uid()
    AND EXISTS (
      SELECT 1 FROM public.tasks
      WHERE tasks.id = task_comments.task_id
      AND (
        tasks.submitted_by = auth.uid()
        OR tasks.assigned_to = auth.uid()
        OR EXISTS (
          SELECT 1 FROM public.profiles
          WHERE profiles.id = auth.uid() AND profiles.role IN ('ceo', 'super_admin')
        )
      )
    )
  );

-- TASK ATTACHMENTS: super_admin can see all
DROP POLICY IF EXISTS "attachments_select" ON public.task_attachments;

CREATE POLICY "attachments_select"
  ON public.task_attachments FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.tasks
      WHERE tasks.id = task_attachments.task_id
      AND (
        tasks.submitted_by = auth.uid()
        OR tasks.assigned_to = auth.uid()
        OR EXISTS (
          SELECT 1 FROM public.profiles
          WHERE profiles.id = auth.uid() AND profiles.role IN ('ceo', 'super_admin')
        )
      )
    )
  );

-- NOTIFICATIONS: super_admin can see all notifications
DROP POLICY IF EXISTS "notifications_select_own" ON public.notifications;

CREATE POLICY "notifications_select"
  ON public.notifications FOR SELECT
  TO authenticated
  USING (
    recipient_id = auth.uid()
    OR EXISTS (
      SELECT 1 FROM public.profiles
      WHERE profiles.id = auth.uid() AND profiles.role = 'super_admin'
    )
  );

-- ALLOWED EMAILS: super_admin has full CRUD
DROP POLICY IF EXISTS "allowed_emails_ceo_select" ON public.allowed_emails;
DROP POLICY IF EXISTS "allowed_emails_ceo_insert" ON public.allowed_emails;
DROP POLICY IF EXISTS "allowed_emails_ceo_delete" ON public.allowed_emails;

CREATE POLICY "allowed_emails_admin_select"
  ON public.allowed_emails FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.profiles
      WHERE profiles.id = auth.uid() AND profiles.role IN ('ceo', 'super_admin')
    )
  );

CREATE POLICY "allowed_emails_admin_insert"
  ON public.allowed_emails FOR INSERT
  TO authenticated
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM public.profiles
      WHERE profiles.id = auth.uid() AND profiles.role IN ('ceo', 'super_admin')
    )
  );

CREATE POLICY "allowed_emails_admin_delete"
  ON public.allowed_emails FOR DELETE
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.profiles
      WHERE profiles.id = auth.uid() AND profiles.role IN ('ceo', 'super_admin')
    )
  );

CREATE POLICY "allowed_emails_admin_update"
  ON public.allowed_emails FOR UPDATE
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.profiles
      WHERE profiles.id = auth.uid() AND profiles.role = 'super_admin'
    )
  );

-- <<< END 003_super_admin_policies.sql

-- >>> BEGIN 004_fix_trigger_and_seed.sql
-- ============================================================
-- Fix: Make handle_new_user trigger fault-tolerant
-- and seed the super admin email into allowed_emails
-- ============================================================

-- Replace the trigger function with an exception-safe version.
-- If anything goes wrong, log it but don't block user creation.
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
DECLARE
  allowed_role user_role;
BEGIN
  SELECT role INTO allowed_role
  FROM public.allowed_emails
  WHERE lower(email) = lower(NEW.email);

  IF allowed_role IS NOT NULL THEN
    INSERT INTO public.profiles (id, email, full_name, role, avatar_url)
    VALUES (
      NEW.id,
      NEW.email,
      COALESCE(
        NEW.raw_user_meta_data->>'full_name',
        NEW.raw_user_meta_data->>'name',
        split_part(NEW.email, '@', 1)
      ),
      allowed_role,
      NEW.raw_user_meta_data->>'avatar_url'
    );
  END IF;

  RETURN NEW;
EXCEPTION WHEN OTHERS THEN
  RAISE LOG 'handle_new_user failed for %: %', NEW.email, SQLERRM;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Seed the super admin / CEO email so a profile gets created on first login.
-- Using ON CONFLICT to make this idempotent (safe to run multiple times).
INSERT INTO public.allowed_emails (email, role)
VALUES ('matija.lekovic@1pax.com', 'ceo')
ON CONFLICT (email) DO NOTHING;

-- <<< END 004_fix_trigger_and_seed.sql

-- >>> BEGIN 005_add_file_link.sql
-- Add optional file link column to tasks (for Dropbox, Google Drive, etc.)
ALTER TABLE public.tasks ADD COLUMN file_link TEXT;

-- <<< END 005_add_file_link.sql

-- >>> BEGIN 006_admin_role_update_policies.sql
-- ============================================================
-- Allow CEO and super_admin to update any profile (for role changes)
-- and any allowed_email entry (for pre-signup role changes)
-- ============================================================

DROP POLICY IF EXISTS "profiles_update" ON public.profiles;

CREATE POLICY "profiles_update"
  ON public.profiles FOR UPDATE
  TO authenticated
  USING (
    auth.uid() = id
    OR EXISTS (
      SELECT 1 FROM public.profiles
      WHERE profiles.id = auth.uid() AND profiles.role IN ('ceo', 'super_admin')
    )
  );

DROP POLICY IF EXISTS "allowed_emails_admin_update" ON public.allowed_emails;

CREATE POLICY "allowed_emails_admin_update"
  ON public.allowed_emails FOR UPDATE
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.profiles
      WHERE profiles.id = auth.uid() AND profiles.role IN ('ceo', 'super_admin')
    )
  );

-- <<< END 006_admin_role_update_policies.sql

-- >>> BEGIN 007_preset_users.sql
-- ============================================================
-- Preset user accounts
--   matija.lekovic@1pax.com   → super_admin
--   mabel.miranda@onepacks.com → ceo
--   mm@onepacks.com            → ceo
-- ============================================================

-- Upsert allowed_emails (insert or update if already present)
INSERT INTO public.allowed_emails (email, role)
VALUES
  ('matija.lekovic@1pax.com',    'super_admin'),
  ('mabel.miranda@1pax.com', 'ceo'),
  ('mm@1pax.com',            'ceo')
ON CONFLICT (email) DO UPDATE SET role = EXCLUDED.role;

-- If any of these users have already signed up, update their profile role too
UPDATE public.profiles SET role = 'super_admin'
WHERE email = 'matija.lekovic@1pax.com' AND role != 'super_admin';

UPDATE public.profiles SET role = 'ceo'
WHERE email IN ('mabel.miranda@onepacks.com', 'mm@onepacks.com') AND role != 'ceo';

-- <<< END 007_preset_users.sql

-- >>> BEGIN 008_fix_preset_users_domains.sql
-- ============================================================
-- Normalize preset users to canonical @1pax.com addresses
-- and ensure roles are synchronized for already-created profiles.
-- ============================================================

-- Canonical allow-list entries
INSERT INTO public.allowed_emails (email, role)
VALUES
  ('matija.lekovic@1pax.com', 'super_admin'),
  ('matija.lekovic@gmail.com', 'team_member'),
  ('mabel.miranda@1pax.com', 'ceo'),
  ('mm@1pax.com', 'ceo')
ON CONFLICT (email) DO UPDATE SET role = EXCLUDED.role;

-- Remove stale domain variants from the allow-list
DELETE FROM public.allowed_emails
WHERE lower(email) IN ('mabel.miranda@onepacks.com', 'mm@onepacks.com');

-- Normalize profile emails if legacy domain values exist
UPDATE public.profiles
SET email = 'mabel.miranda@1pax.com'
WHERE lower(email) = 'mabel.miranda@onepacks.com';

UPDATE public.profiles
SET email = 'mm@1pax.com'
WHERE lower(email) = 'mm@onepacks.com';

-- Keep role assignments correct for both canonical + legacy records
UPDATE public.profiles
SET role = 'super_admin'
WHERE lower(email) = 'matija.lekovic@1pax.com'
  AND role != 'super_admin';

UPDATE public.profiles
SET role = 'team_member'
WHERE lower(email) = 'matija.lekovic@gmail.com'
  AND role != 'team_member';

UPDATE public.profiles
SET role = 'ceo'
WHERE lower(email) IN (
  'mabel.miranda@1pax.com',
  'mabel.miranda@onepacks.com',
  'mm@1pax.com',
  'mm@onepacks.com'
)
  AND role != 'ceo';

-- <<< END 008_fix_preset_users_domains.sql

-- >>> BEGIN 009_task_events_and_transition_fn.sql
-- ============================================================
-- Task events + transition RPC
-- ============================================================

-- Enforce delegated tasks always having an assignee.
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM pg_constraint
    WHERE conname = 'tasks_delegated_requires_assignee'
  ) THEN
    ALTER TABLE public.tasks
      ADD CONSTRAINT tasks_delegated_requires_assignee
      CHECK (status <> 'delegated' OR assigned_to IS NOT NULL);
  END IF;
END $$;

-- Immutable workflow event log
CREATE TABLE IF NOT EXISTS public.task_events (
  id          UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  task_id     UUID NOT NULL REFERENCES public.tasks(id) ON DELETE CASCADE,
  actor_id    UUID NOT NULL REFERENCES public.profiles(id),
  action      TEXT NOT NULL,
  from_status task_status NOT NULL,
  to_status   task_status NOT NULL,
  note        TEXT,
  created_at  TIMESTAMPTZ NOT NULL DEFAULT now()
);

DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM pg_constraint
    WHERE conname = 'task_events_action_check'
  ) THEN
    ALTER TABLE public.task_events
      ADD CONSTRAINT task_events_action_check
      CHECK (
        action IN (
          'request_info',
          'delegate',
          'approve',
          'reject',
          'defer',
          'resolve',
          'mark_ready',
          'provide_info'
        )
      );
  END IF;
END $$;

CREATE INDEX IF NOT EXISTS idx_task_events_task_created
  ON public.task_events(task_id, created_at DESC);

CREATE INDEX IF NOT EXISTS idx_task_events_actor_created
  ON public.task_events(actor_id, created_at DESC);

CREATE OR REPLACE FUNCTION public.enforce_task_status_transition()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  IF NEW.status IS DISTINCT FROM OLD.status
     AND current_setting('app.task_transition', true) IS DISTINCT FROM '1' THEN
    RAISE EXCEPTION 'Task status changes must use transition_task()';
  END IF;

  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS trg_enforce_task_status_transition ON public.tasks;
CREATE TRIGGER trg_enforce_task_status_transition
  BEFORE UPDATE ON public.tasks
  FOR EACH ROW
  EXECUTE FUNCTION public.enforce_task_status_transition();

ALTER TABLE public.task_events ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "task_events_select" ON public.task_events;

CREATE POLICY "task_events_select"
  ON public.task_events FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1
      FROM public.tasks t
      JOIN public.profiles me ON me.id = auth.uid()
      WHERE t.id = task_events.task_id
        AND me.is_active = true
        AND (
          me.role IN ('ceo', 'super_admin')
          OR t.submitted_by = auth.uid()
          OR t.assigned_to = auth.uid()
        )
    )
  );

CREATE OR REPLACE FUNCTION public.transition_task(
  p_task_id uuid,
  p_action text,
  p_note text DEFAULT NULL,
  p_assigned_to uuid DEFAULT NULL
)
RETURNS public.tasks
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_actor_id uuid := auth.uid();
  v_actor_role user_role;
  v_actor_active boolean;
  v_is_admin boolean := false;
  v_task public.tasks%ROWTYPE;
  v_updated public.tasks%ROWTYPE;
  v_action text := lower(trim(p_action));
  v_note text := NULLIF(trim(COALESCE(p_note, '')), '');
  v_new_status task_status;
BEGIN
  IF v_actor_id IS NULL THEN
    RAISE EXCEPTION 'Authentication required';
  END IF;

  SELECT role, is_active
  INTO v_actor_role, v_actor_active
  FROM public.profiles
  WHERE id = v_actor_id;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Profile not found for authenticated user';
  END IF;

  IF v_actor_active IS DISTINCT FROM true THEN
    RAISE EXCEPTION 'Inactive users cannot transition tasks';
  END IF;

  v_is_admin := v_actor_role IN ('ceo', 'super_admin');

  SELECT *
  INTO v_task
  FROM public.tasks
  WHERE id = p_task_id
    AND is_archived = false
  FOR UPDATE;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Task not found or archived';
  END IF;

  IF NOT (
    v_is_admin
    OR v_task.submitted_by = v_actor_id
    OR v_task.assigned_to = v_actor_id
  ) THEN
    RAISE EXCEPTION 'You do not have access to this task';
  END IF;

  CASE v_action
    WHEN 'approve' THEN
      IF NOT v_is_admin THEN
        RAISE EXCEPTION 'Only CEO or super_admin can approve';
      END IF;
      IF v_task.status IN ('approved', 'rejected', 'resolved') THEN
        RAISE EXCEPTION 'Cannot approve a final-status task';
      END IF;
      v_new_status := 'approved';

    WHEN 'reject' THEN
      IF NOT v_is_admin THEN
        RAISE EXCEPTION 'Only CEO or super_admin can reject';
      END IF;
      IF v_task.status IN ('approved', 'rejected', 'resolved') THEN
        RAISE EXCEPTION 'Cannot reject a final-status task';
      END IF;
      v_new_status := 'rejected';

    WHEN 'defer' THEN
      IF NOT v_is_admin THEN
        RAISE EXCEPTION 'Only CEO or super_admin can defer';
      END IF;
      IF v_task.status IN ('approved', 'rejected', 'resolved') THEN
        RAISE EXCEPTION 'Cannot defer a final-status task';
      END IF;
      v_new_status := 'deferred';

    WHEN 'resolve' THEN
      IF NOT v_is_admin THEN
        RAISE EXCEPTION 'Only CEO or super_admin can resolve';
      END IF;
      IF v_task.status IN ('approved', 'rejected', 'resolved') THEN
        RAISE EXCEPTION 'Cannot resolve a final-status task';
      END IF;
      v_new_status := 'resolved';

    WHEN 'request_info' THEN
      IF NOT v_is_admin THEN
        RAISE EXCEPTION 'Only CEO or super_admin can request more information';
      END IF;
      IF v_task.status IN ('approved', 'rejected', 'resolved') THEN
        RAISE EXCEPTION 'Cannot request info on a final-status task';
      END IF;
      v_new_status := 'needs_more_info';

    WHEN 'delegate' THEN
      IF NOT v_is_admin THEN
        RAISE EXCEPTION 'Only CEO or super_admin can delegate';
      END IF;
      IF v_task.status IN ('approved', 'rejected', 'resolved') THEN
        RAISE EXCEPTION 'Cannot delegate a final-status task';
      END IF;
      IF p_assigned_to IS NULL THEN
        RAISE EXCEPTION 'Delegation requires assigned_to';
      END IF;

      PERFORM 1
      FROM public.profiles assignee
      WHERE assignee.id = p_assigned_to
        AND assignee.is_active = true;

      IF NOT FOUND THEN
        RAISE EXCEPTION 'Delegation assignee must be an active user';
      END IF;

      v_new_status := 'delegated';

    WHEN 'mark_ready' THEN
      IF v_task.status <> 'delegated' THEN
        RAISE EXCEPTION 'mark_ready is only valid from delegated';
      END IF;
      IF v_task.assigned_to IS DISTINCT FROM v_actor_id THEN
        RAISE EXCEPTION 'Only assignee can mark delegated task as ready';
      END IF;
      v_new_status := 'in_review';

    WHEN 'provide_info' THEN
      IF v_task.status <> 'needs_more_info' THEN
        RAISE EXCEPTION 'provide_info is only valid from needs_more_info';
      END IF;
      IF v_task.submitted_by IS DISTINCT FROM v_actor_id THEN
        RAISE EXCEPTION 'Only submitter can provide requested info';
      END IF;
      v_new_status := 'pending';

    ELSE
      RAISE EXCEPTION 'Unsupported transition action: %', p_action;
  END CASE;

  PERFORM set_config('app.task_transition', '1', true);

  UPDATE public.tasks t
  SET
    status = v_new_status,
    assigned_to = CASE
      WHEN v_action = 'delegate' THEN p_assigned_to
      WHEN v_action = 'request_info' THEN NULL
      ELSE t.assigned_to
    END,
    delegation_note = CASE
      WHEN v_action = 'delegate' THEN v_note
      ELSE t.delegation_note
    END,
    resolution_note = CASE
      WHEN v_action IN ('approve', 'reject', 'defer', 'resolve', 'request_info') THEN v_note
      ELSE t.resolution_note
    END,
    resolved_by = CASE
      WHEN v_action IN ('approve', 'reject', 'defer', 'resolve', 'request_info') THEN v_actor_id
      ELSE t.resolved_by
    END,
    resolved_at = CASE
      WHEN v_action IN ('approve', 'reject', 'defer', 'resolve', 'request_info') THEN now()
      ELSE t.resolved_at
    END
  WHERE t.id = p_task_id
  RETURNING * INTO v_updated;

  INSERT INTO public.task_events (
    task_id,
    actor_id,
    action,
    from_status,
    to_status,
    note
  )
  VALUES (
    v_updated.id,
    v_actor_id,
    v_action,
    v_task.status,
    v_new_status,
    v_note
  );

  RETURN v_updated;
END;
$$;

REVOKE ALL ON FUNCTION public.transition_task(uuid, text, text, uuid) FROM PUBLIC;
GRANT EXECUTE ON FUNCTION public.transition_task(uuid, text, text, uuid) TO authenticated;

DO $$
BEGIN
  BEGIN
    ALTER PUBLICATION supabase_realtime ADD TABLE public.task_events;
  EXCEPTION
    WHEN duplicate_object THEN NULL;
  END;
END $$;

-- <<< END 009_task_events_and_transition_fn.sql

-- >>> BEGIN 010_harden_task_rls.sql
-- ============================================================
-- Harden task RLS around active users and admin-only direct updates
-- ============================================================

DROP POLICY IF EXISTS "tasks_select" ON public.tasks;
DROP POLICY IF EXISTS "tasks_insert" ON public.tasks;
DROP POLICY IF EXISTS "tasks_update" ON public.tasks;
DROP POLICY IF EXISTS "tasks_delete" ON public.tasks;

CREATE POLICY "tasks_select"
  ON public.tasks FOR SELECT
  TO authenticated
  USING (
    EXISTS (
      SELECT 1
      FROM public.profiles me
      WHERE me.id = auth.uid()
        AND me.is_active = true
        AND (
          me.role IN ('ceo', 'super_admin')
          OR tasks.submitted_by = auth.uid()
          OR tasks.assigned_to = auth.uid()
        )
    )
  );

CREATE POLICY "tasks_insert"
  ON public.tasks FOR INSERT
  TO authenticated
  WITH CHECK (
    submitted_by = auth.uid()
    AND status = 'pending'
    AND assigned_to IS NULL
    AND EXISTS (
      SELECT 1
      FROM public.profiles me
      WHERE me.id = auth.uid()
        AND me.is_active = true
    )
  );

CREATE POLICY "tasks_update"
  ON public.tasks FOR UPDATE
  TO authenticated
  USING (
    EXISTS (
      SELECT 1
      FROM public.profiles me
      WHERE me.id = auth.uid()
        AND me.is_active = true
        AND me.role IN ('ceo', 'super_admin')
    )
  )
  WITH CHECK (
    EXISTS (
      SELECT 1
      FROM public.profiles me
      WHERE me.id = auth.uid()
        AND me.is_active = true
        AND me.role IN ('ceo', 'super_admin')
    )
  );

CREATE POLICY "tasks_delete"
  ON public.tasks FOR DELETE
  TO authenticated
  USING (
    EXISTS (
      SELECT 1
      FROM public.profiles me
      WHERE me.id = auth.uid()
        AND me.is_active = true
        AND me.role = 'super_admin'
    )
  );

-- <<< END 010_harden_task_rls.sql

-- >>> BEGIN 011_notification_triggers.sql
-- ============================================================
-- Notification triggers for task lifecycle events
-- ============================================================

CREATE OR REPLACE FUNCTION public.notify_task_submitted()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  INSERT INTO public.notifications (
    recipient_id,
    type,
    title,
    message,
    task_id
  )
  SELECT
    p.id,
    'task_submitted',
    'New task submitted',
    format('New %s task: %s', replace(NEW.category::text, '_', ' '), NEW.title),
    NEW.id
  FROM public.profiles p
  WHERE p.role IN ('ceo', 'super_admin')
    AND p.is_active = true
    AND p.id <> NEW.submitted_by;

  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS trg_notify_task_submitted ON public.tasks;
CREATE TRIGGER trg_notify_task_submitted
  AFTER INSERT ON public.tasks
  FOR EACH ROW
  EXECUTE FUNCTION public.notify_task_submitted();

CREATE OR REPLACE FUNCTION public.notify_task_event()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_task public.tasks%ROWTYPE;
BEGIN
  SELECT *
  INTO v_task
  FROM public.tasks
  WHERE id = NEW.task_id;

  IF NOT FOUND THEN
    RETURN NEW;
  END IF;

  CASE NEW.action
    WHEN 'delegate' THEN
      IF v_task.assigned_to IS NOT NULL AND v_task.assigned_to <> NEW.actor_id THEN
        INSERT INTO public.notifications (
          recipient_id,
          type,
          title,
          message,
          task_id
        )
        VALUES (
          v_task.assigned_to,
          'task_delegated',
          'Task delegated to you',
          format('%s: %s', v_task.reference_number, v_task.title),
          v_task.id
        );
      END IF;

    WHEN 'request_info' THEN
      IF v_task.submitted_by <> NEW.actor_id THEN
        INSERT INTO public.notifications (
          recipient_id,
          type,
          title,
          message,
          task_id
        )
        VALUES (
          v_task.submitted_by,
          'needs_more_info',
          'More information needed',
          format('%s: %s', v_task.reference_number, v_task.title),
          v_task.id
        );
      END IF;

    WHEN 'provide_info' THEN
      INSERT INTO public.notifications (
        recipient_id,
        type,
        title,
        message,
        task_id
      )
      SELECT
        p.id,
        'info_provided',
        'Information provided',
        format('%s: %s', v_task.reference_number, v_task.title),
        v_task.id
      FROM public.profiles p
      WHERE p.role IN ('ceo', 'super_admin')
        AND p.is_active = true
        AND p.id <> NEW.actor_id;

    WHEN 'mark_ready' THEN
      INSERT INTO public.notifications (
        recipient_id,
        type,
        title,
        message,
        task_id
      )
      SELECT
        p.id,
        'task_updated',
        'Task ready for review',
        format('%s: %s', v_task.reference_number, v_task.title),
        v_task.id
      FROM public.profiles p
      WHERE p.role IN ('ceo', 'super_admin')
        AND p.is_active = true
        AND p.id <> NEW.actor_id;

    WHEN 'approve' THEN
      IF v_task.submitted_by <> NEW.actor_id THEN
        INSERT INTO public.notifications (
          recipient_id,
          type,
          title,
          message,
          task_id
        )
        VALUES (
          v_task.submitted_by,
          'task_resolved',
          'Task approved',
          format('%s: %s', v_task.reference_number, v_task.title),
          v_task.id
        );
      END IF;

    WHEN 'reject' THEN
      IF v_task.submitted_by <> NEW.actor_id THEN
        INSERT INTO public.notifications (
          recipient_id,
          type,
          title,
          message,
          task_id
        )
        VALUES (
          v_task.submitted_by,
          'task_resolved',
          'Task rejected',
          format('%s: %s', v_task.reference_number, v_task.title),
          v_task.id
        );
      END IF;

    WHEN 'resolve' THEN
      IF v_task.submitted_by <> NEW.actor_id THEN
        INSERT INTO public.notifications (
          recipient_id,
          type,
          title,
          message,
          task_id
        )
        VALUES (
          v_task.submitted_by,
          'task_resolved',
          'Task resolved',
          format('%s: %s', v_task.reference_number, v_task.title),
          v_task.id
        );
      END IF;

    WHEN 'defer' THEN
      IF v_task.submitted_by <> NEW.actor_id THEN
        INSERT INTO public.notifications (
          recipient_id,
          type,
          title,
          message,
          task_id
        )
        VALUES (
          v_task.submitted_by,
          'task_updated',
          'Task deferred',
          format('%s: %s', v_task.reference_number, v_task.title),
          v_task.id
        );
      END IF;
  END CASE;

  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS trg_notify_task_event ON public.task_events;
CREATE TRIGGER trg_notify_task_event
  AFTER INSERT ON public.task_events
  FOR EACH ROW
  EXECUTE FUNCTION public.notify_task_event();

CREATE OR REPLACE FUNCTION public.notify_task_comment_added()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_task public.tasks%ROWTYPE;
BEGIN
  SELECT *
  INTO v_task
  FROM public.tasks
  WHERE id = NEW.task_id;

  IF NOT FOUND THEN
    RETURN NEW;
  END IF;

  INSERT INTO public.notifications (
    recipient_id,
    type,
    title,
    message,
    task_id
  )
  SELECT
    recipients.recipient_id,
    'comment_added',
    'New comment added',
    format('%s: %s', v_task.reference_number, v_task.title),
    v_task.id
  FROM (
    SELECT v_task.submitted_by AS recipient_id
    UNION
    SELECT v_task.assigned_to
    UNION
    SELECT p.id
    FROM public.profiles p
    WHERE p.role IN ('ceo', 'super_admin')
      AND p.is_active = true
  ) recipients
  WHERE recipients.recipient_id IS NOT NULL
    AND recipients.recipient_id <> NEW.author_id;

  RETURN NEW;
END;
$$;

DROP TRIGGER IF EXISTS trg_notify_task_comment_added ON public.task_comments;
CREATE TRIGGER trg_notify_task_comment_added
  AFTER INSERT ON public.task_comments
  FOR EACH ROW
  EXECUTE FUNCTION public.notify_task_comment_added();

-- <<< END 011_notification_triggers.sql

